;; NOTE: Assertions have been generated by update_lit_checks.py --all-items and should not be edited.
;; RUN: foreach %s %t wasm-opt -all --gufa -tnh -S -o - | filecheck %s

(module
  ;; CHECK:      (type $funcref_funcref_funcref_funcref_=>_none (func (param funcref funcref funcref funcref)))

  ;; CHECK:      (type $none_=>_none (func))

  ;; CHECK:      (import "a" "b" (global $unknown-i32 i32))
  (import "a" "b" (global $unknown-i32 i32))

  ;; CHECK:      (import "a" "b" (global $unknown-funcref1 funcref))
  (import "a" "b" (global $unknown-funcref1 funcref))

  ;; CHECK:      (import "a" "b" (global $unknown-funcref2 funcref))
  (import "a" "b" (global $unknown-funcref2 funcref))

  ;; CHECK:      (import "a" "b" (global $unknown-nn-func1 (ref func)))
  (import "a" "b" (global $unknown-nn-func1 (ref func)))

  ;; CHECK:      (import "a" "b" (global $unknown-nn-func2 (ref func)))
  (import "a" "b" (global $unknown-nn-func2 (ref func)))

  ;; CHECK:      (func $called (type $funcref_funcref_funcref_funcref_=>_none) (param $x funcref) (param $no-cast funcref) (param $y funcref) (param $z funcref)
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (ref.as_func
  ;; CHECK-NEXT:    (local.get $x)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (ref.as_func
  ;; CHECK-NEXT:    (local.get $y)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (ref.as_func
  ;; CHECK-NEXT:    (local.get $z)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $called (param $x funcref) (param $no-cast funcref) (param $y funcref) (param $z funcref)
    ;; All but the second parameter are cast here, which allows some
    ;; optimization in the caller. Nothing significant changes here.
    (drop
      (ref.cast func
        (local.get $x)
      )
    )
    (drop
      (ref.cast func
        (local.get $y)
      )
    )
    (drop
      (ref.cast func
        (local.get $z)
      )
    )
  )

  ;; CHECK:      (func $caller (type $none_=>_none)
  ;; CHECK-NEXT:  (local $f funcref)
  ;; CHECK-NEXT:  (local.set $f
  ;; CHECK-NEXT:   (select (result funcref)
  ;; CHECK-NEXT:    (global.get $unknown-funcref1)
  ;; CHECK-NEXT:    (global.get $unknown-funcref2)
  ;; CHECK-NEXT:    (global.get $unknown-i32)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (call $called
  ;; CHECK-NEXT:   (ref.as_func
  ;; CHECK-NEXT:    (local.get $f)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:   (ref.cast null func
  ;; CHECK-NEXT:    (local.get $f)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:   (local.get $f)
  ;; CHECK-NEXT:   (ref.as_func
  ;; CHECK-NEXT:    (local.get $f)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (call $called
  ;; CHECK-NEXT:   (ref.as_func
  ;; CHECK-NEXT:    (local.get $f)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:   (local.get $f)
  ;; CHECK-NEXT:   (ref.as_func
  ;; CHECK-NEXT:    (local.get $f)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:   (ref.as_func
  ;; CHECK-NEXT:    (local.get $f)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $caller
    (local $f funcref)

    ;; Fill the local with an unknown value (so that trivial inference doesn't
    ;; optimize away the thing we care about below).
    (local.set $f
      (select
        (global.get $unknown-funcref1)
        (global.get $unknown-funcref2)
        (global.get $unknown-i32)
      )
    )

    ;; All but the third parameter are cast here. The cast has no effect by
    ;; itself as the type is funcref, but GUFA will refine casts when it can
    ;; (but not add a new cast, which might not be worth it).
    ;;
    ;; Specifically here, the first and last cast can be refined, since those
    ;; are cast both here and in the called function. Those casts will lose the
    ;; "null" and become non-nullable.
    (call $called
      (ref.cast null func
        (local.get $f)
      )
      (ref.cast null func
        (local.get $f)
      )
      (local.get $f)
      (ref.cast null func
        (local.get $f)
      )
    )

    ;; Another call, but with different casts.
    (call $called
      (ref.cast func ;; this is now non-nullable, and will not change
        (local.get $f)
      )
      (local.get $f) ;; this is not cast, and will not change.
      (ref.cast null func
        (local.get $f) ;; this is now cast, and will be optimized.
      )
      (ref.cast null func ;; this is the same as before, and will be optimized.
        (local.get $f)
      )
    )
  )
)

(module
  ;; CHECK:      (type $A (struct (field (mut i32))))
  (type $A (struct (field (mut i32))))

  ;; CHECK:      (type $B (sub $A (struct (field (mut i32)))))
  (type $B (sub $A (struct (field (mut i32)))))

  ;; CHECK:      (type $none_=>_none (func))

  ;; CHECK:      (type $ref?|$A|_=>_none (func (param (ref null $A))))

  ;; CHECK:      (type $anyref_=>_none (func (param anyref)))

  ;; CHECK:      (export "out" (func $caller))

  ;; CHECK:      (func $maker (type $none_=>_none)
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.new $A
  ;; CHECK-NEXT:    (i32.const 10)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.new $B
  ;; CHECK-NEXT:    (i32.const 20)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $maker
    ;; A always contains 10, and B always contains 20.
    (drop
      (struct.new $A
        (i32.const 10)
      )
    )
    (drop
      (struct.new $B
        (i32.const 20)
      )
    )
  )

  ;; CHECK:      (func $called (type $ref?|$A|_=>_none) (param $x (ref null $A))
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (ref.cast $B
  ;; CHECK-NEXT:    (local.get $x)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $called (param $x (ref null $A))
    ;; Cast the input to a $B, which will help the caller.
    (drop
      (ref.cast $B
        (local.get $x)
      )
    )
  )

  ;; CHECK:      (func $caller (type $anyref_=>_none) (param $any anyref)
  ;; CHECK-NEXT:  (local $x (ref null $A))
  ;; CHECK-NEXT:  (call $called
  ;; CHECK-NEXT:   (local.tee $x
  ;; CHECK-NEXT:    (ref.cast $B
  ;; CHECK-NEXT:     (local.get $any)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.get $A 0
  ;; CHECK-NEXT:    (ref.cast $A
  ;; CHECK-NEXT:     (local.get $any)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (ref.test $B
  ;; CHECK-NEXT:    (local.get $any)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (i32.const 20)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (i32.const 1)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $caller (export "out") (param $any anyref)
    (local $x (ref null $A))
    ;; The called function casts to $B. This lets us infer the value of the
    ;; fallthrough ref.cast, which will turn into $B. Furthermore, that then
    ;; tells us what is written into the local $x, and the forward flow
    ;; analysis will use that fact in the local.get $x below.
    (call $called
      (local.tee $x
        (ref.cast $A
          (local.get $any)
        )
      )
    )
    ;; We can't infer anything here at the moment, but a more sophisticated
    ;; analysis could. (Other passes can help here, however, by using $x where
    ;; $any appears.)
    (drop
      (struct.get $A 0
        (ref.cast $A
          (local.get $any)
        )
      )
    )
    (drop
      (ref.test $B
        (local.get $any)
      )
    )
    ;; We know that $x must contain $B, so this can be inferred to be 20, and
    ;; the ref.is to 1.
    (drop
      (struct.get $A 0
        (local.get $x)
      )
    )
    (drop
      (ref.test $B
        (local.get $x)
      )
    )
  )
)
