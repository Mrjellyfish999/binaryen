;; NOTE: Assertions have been generated by update_lit_checks.py and should not be edited.
;; RUN: foreach %s %t wasm-opt -all --efo --nominal -S -o - | filecheck %s

(module
  ;; CHECK:      (type $A (struct (field i32) (field i32)))
  (type $A (struct (field i32) (field i32)))
  ;; CHECK:      (type $B (struct (field i32) (field i32)))
  (type $B (struct (field i32) (field i32)))

  ;; CHECK:      (func $A (type $none_=>_none)
  ;; CHECK-NEXT:  (local $ref (ref $A))
  ;; CHECK-NEXT:  (local.set $ref
  ;; CHECK-NEXT:   (struct.new $A
  ;; CHECK-NEXT:    (i32.const 10)
  ;; CHECK-NEXT:    (i32.const 10)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.get $A 0
  ;; CHECK-NEXT:    (local.get $ref)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.get $A 0
  ;; CHECK-NEXT:    (local.get $ref)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (block ;; (replaces something unreachable we can't emit)
  ;; CHECK-NEXT:    (drop
  ;; CHECK-NEXT:     (unreachable)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (drop
  ;; CHECK-NEXT:     (i32.const 11)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (unreachable)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (block ;; (replaces something unreachable we can't emit)
  ;; CHECK-NEXT:    (drop
  ;; CHECK-NEXT:     (unreachable)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (unreachable)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $A
    (local $ref (ref $A))
    ;; $A is always written the same value in both fields, so they are
    ;; equivalent, and we optimize to always read from field #0.
    (local.set $ref
      (struct.new $A
        (i32.const 10)
        (i32.const 10)
      )
    )
    (drop
      (struct.get $A 0
        (local.get $ref)
      )
    )
    (drop
      (struct.get $A 1   ;; This will be optimized to 0.
        (local.get $ref)
      )
    )
    ;; Unreachable things are ignored, and do not interfere with optimization.
    (drop
      (struct.new $A
        (unreachable)
        (i32.const 11)
      )
    )
    (drop
      (struct.get $A 1
        (unreachable)
      )
    )
  )

  ;; CHECK:      (func $B (type $none_=>_none)
  ;; CHECK-NEXT:  (local $ref (ref $B))
  ;; CHECK-NEXT:  (local.set $ref
  ;; CHECK-NEXT:   (struct.new $B
  ;; CHECK-NEXT:    (i32.const 10)
  ;; CHECK-NEXT:    (i32.const 11)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.get $B 0
  ;; CHECK-NEXT:    (local.get $ref)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.get $B 1
  ;; CHECK-NEXT:    (local.get $ref)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $B
    (local $ref (ref $B))
    (local.set $ref
      (struct.new $B
        (i32.const 10)
        (i32.const 11) ;; This value is different, so in this function we do not
                       ;; optimize at all, and the get indexes remain 0, 1.
      )
    )
    (drop
      (struct.get $B 0
        (local.get $ref)
      )
    )
    (drop
      (struct.get $B 1
        (local.get $ref)
      )
    )
  )
)

(module
  ;; CHECK:      (type $A (struct (field i32) (field i32)))
  (type $A (struct (field i32) (field i32)))

  ;; CHECK:      (func $A (type $i32_=>_none) (param $x i32)
  ;; CHECK-NEXT:  (local $ref (ref null $A))
  ;; CHECK-NEXT:  (if
  ;; CHECK-NEXT:   (local.get $x)
  ;; CHECK-NEXT:   (local.set $ref
  ;; CHECK-NEXT:    (struct.new $A
  ;; CHECK-NEXT:     (i32.const 10)
  ;; CHECK-NEXT:     (i32.const 10)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:   (local.set $ref
  ;; CHECK-NEXT:    (struct.new $A
  ;; CHECK-NEXT:     (i32.const 20)
  ;; CHECK-NEXT:     (i32.const 20)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.get $A 0
  ;; CHECK-NEXT:    (local.get $ref)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $A (param $x i32)
    (local $ref (ref null $A))
    ;; Two struct.news, each with different values - but the equivalances are
    ;; the same in both, so we can optimize the get index below to 0.
    (if
      (local.get $x)
      (local.set $ref
        (struct.new $A
          (i32.const 10)
          (i32.const 10)
        )
      )
      (local.set $ref
        (struct.new $A
          (i32.const 20)
          (i32.const 20)
        )
      )
    )
    (drop
      (struct.get $A 1
        (local.get $ref)
      )
    )
  )
)

(module
  ;; CHECK:      (type $A (struct (field i32) (field i32)))
  (type $A (struct (field i32) (field i32)))

  ;; CHECK:      (func $A (type $i32_=>_none) (param $x i32)
  ;; CHECK-NEXT:  (local $ref (ref null $A))
  ;; CHECK-NEXT:  (if
  ;; CHECK-NEXT:   (local.get $x)
  ;; CHECK-NEXT:   (local.set $ref
  ;; CHECK-NEXT:    (struct.new $A
  ;; CHECK-NEXT:     (i32.const 10)
  ;; CHECK-NEXT:     (i32.const 10)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:   (local.set $ref
  ;; CHECK-NEXT:    (struct.new $A
  ;; CHECK-NEXT:     (i32.const 20)
  ;; CHECK-NEXT:     (i32.const 22)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.get $A 1
  ;; CHECK-NEXT:    (local.get $ref)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $A (param $x i32)
    (local $ref (ref null $A))
    (if
      (local.get $x)
      (local.set $ref
        (struct.new $A
          (i32.const 10)
          (i32.const 10)
        )
      )
      (local.set $ref
        (struct.new $A
          (i32.const 20)
          (i32.const 22) ;; This changed, so we do not optimize. One struct.new
                         ;; without the proper equivalences stops us.
        )
      )
    )
    (drop
      (struct.get $A 1
        (local.get $ref)
      )
    )
  )
)

(module
  ;; CHECK:      (type $A (struct (field i32) (field i32)))
  (type $A (struct (field i32) (field i32)))

  ;; CHECK:      (func $A (type $i32_=>_none) (param $x i32)
  ;; CHECK-NEXT:  (local $ref (ref null $A))
  ;; CHECK-NEXT:  (if
  ;; CHECK-NEXT:   (local.get $x)
  ;; CHECK-NEXT:   (local.set $ref
  ;; CHECK-NEXT:    (struct.new $A
  ;; CHECK-NEXT:     (i32.const 10)
  ;; CHECK-NEXT:     (i32.const 11)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:   (local.set $ref
  ;; CHECK-NEXT:    (struct.new $A
  ;; CHECK-NEXT:     (i32.const 20)
  ;; CHECK-NEXT:     (i32.const 20)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.get $A 1
  ;; CHECK-NEXT:    (local.get $ref)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $A (param $x i32)
    (local $ref (ref null $A))
    (if
      (local.get $x)
      (local.set $ref
        (struct.new $A
          (i32.const 10)
          (i32.const 11) ;; This changed, so we do not optimize. This is the
                         ;; same as the last testcase, but now the lack of
                         ;; equivalence is in the first struct.new.
        )
      )
      (local.set $ref
        (struct.new $A
          (i32.const 20)
          (i32.const 20)
        )
      )
    )
    (drop
      (struct.get $A 1
        (local.get $ref)
      )
    )
  )
)

;; Test separate functions and a struct.new in a global. Here we can optimize.
(module
  ;; CHECK:      (type $A (struct (field i32) (field i32)))
  (type $A (struct (field i32) (field i32)))

  ;; CHECK:      (global $A (ref $A) (struct.new $A
  ;; CHECK-NEXT:  (i32.const 10)
  ;; CHECK-NEXT:  (i32.const 10)
  ;; CHECK-NEXT: ))
  (global $A (ref $A) (struct.new $A
    (i32.const 10)
    (i32.const 10)
  ))

  ;; CHECK:      (func $new-0 (type $none_=>_none)
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.new $A
  ;; CHECK-NEXT:    (i32.const 20)
  ;; CHECK-NEXT:    (i32.const 20)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $new-0
    (drop
      (struct.new $A
        (i32.const 20)
        (i32.const 20)
      )
    )
  )

  ;; CHECK:      (func $new-1 (type $none_=>_none)
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.new $A
  ;; CHECK-NEXT:    (i32.const 20)
  ;; CHECK-NEXT:    (i32.const 20)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $new-1
    (drop
      (struct.new $A
        (i32.const 20)
        (i32.const 20)
      )
    )
  )

  ;; CHECK:      (func $get (type $ref|$A|_=>_i32) (param $ref (ref $A)) (result i32)
  ;; CHECK-NEXT:  (struct.get $A 0
  ;; CHECK-NEXT:   (local.get $ref)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $get (param $ref (ref $A)) (result i32)
    (struct.get $A 1
      (local.get $ref)
    )
  )
)

;; Non-equivalence in the global prevents optimization.
(module
  ;; CHECK:      (type $A (struct (field i32) (field i32)))
  (type $A (struct (field i32) (field i32)))

  ;; CHECK:      (global $A (ref $A) (struct.new $A
  ;; CHECK-NEXT:  (i32.const 10)
  ;; CHECK-NEXT:  (i32.const 11)
  ;; CHECK-NEXT: ))
  (global $A (ref $A) (struct.new $A
    (i32.const 10)
    (i32.const 11) ;; This changed.
  ))

  ;; CHECK:      (func $new-0 (type $none_=>_none)
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.new $A
  ;; CHECK-NEXT:    (i32.const 20)
  ;; CHECK-NEXT:    (i32.const 20)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $new-0
    (drop
      (struct.new $A
        (i32.const 20)
        (i32.const 20)
      )
    )
  )

  ;; CHECK:      (func $new-1 (type $none_=>_none)
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.new $A
  ;; CHECK-NEXT:    (i32.const 20)
  ;; CHECK-NEXT:    (i32.const 20)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $new-1
    (drop
      (struct.new $A
        (i32.const 20)
        (i32.const 20)
      )
    )
  )

  ;; CHECK:      (func $get (type $ref|$A|_=>_i32) (param $ref (ref $A)) (result i32)
  ;; CHECK-NEXT:  (struct.get $A 1
  ;; CHECK-NEXT:   (local.get $ref)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $get (param $ref (ref $A)) (result i32)
    (struct.get $A 1
      (local.get $ref)
    )
  )
)

;; Non-equivalence in a function prevents optimization.
(module
  ;; CHECK:      (type $A (struct (field i32) (field i32)))
  (type $A (struct (field i32) (field i32)))

  ;; CHECK:      (global $A (ref $A) (struct.new $A
  ;; CHECK-NEXT:  (i32.const 10)
  ;; CHECK-NEXT:  (i32.const 10)
  ;; CHECK-NEXT: ))
  (global $A (ref $A) (struct.new $A
    (i32.const 10)
    (i32.const 10)
  ))

  ;; CHECK:      (func $new-0 (type $none_=>_none)
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.new $A
  ;; CHECK-NEXT:    (i32.const 20)
  ;; CHECK-NEXT:    (i32.const 20)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $new-0
    (drop
      (struct.new $A
        (i32.const 20)
        (i32.const 20)
      )
    )
  )

  ;; CHECK:      (func $new-1 (type $none_=>_none)
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.new $A
  ;; CHECK-NEXT:    (i32.const 20)
  ;; CHECK-NEXT:    (i32.const 22)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $new-1
    (drop
      (struct.new $A
        (i32.const 20)
        (i32.const 22) ;; This changed.
      )
    )
  )

  ;; CHECK:      (func $get (type $ref|$A|_=>_i32) (param $ref (ref $A)) (result i32)
  ;; CHECK-NEXT:  (struct.get $A 1
  ;; CHECK-NEXT:   (local.get $ref)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $get (param $ref (ref $A)) (result i32)
    (struct.get $A 1
      (local.get $ref)
    )
  )
)

;; Four fields.
(module
  ;; CHECK:      (type $A (struct (field i32) (field i32) (field i32) (field i32)))
  (type $A (struct (field i32) (field i32) (field i32) (field i32)))

  ;; CHECK:      (func $A (type $i32_=>_none) (param $x i32)
  ;; CHECK-NEXT:  (local $ref (ref null $A))
  ;; CHECK-NEXT:  (if
  ;; CHECK-NEXT:   (local.get $x)
  ;; CHECK-NEXT:   (local.set $ref
  ;; CHECK-NEXT:    (struct.new $A
  ;; CHECK-NEXT:     (i32.const 10)
  ;; CHECK-NEXT:     (i32.const 10)
  ;; CHECK-NEXT:     (i32.const 20)
  ;; CHECK-NEXT:     (i32.const 20)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:   (local.set $ref
  ;; CHECK-NEXT:    (struct.new $A
  ;; CHECK-NEXT:     (i32.const 10)
  ;; CHECK-NEXT:     (i32.const 20)
  ;; CHECK-NEXT:     (i32.const 20)
  ;; CHECK-NEXT:     (i32.const 30)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.get $A 0
  ;; CHECK-NEXT:    (local.get $ref)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.get $A 1
  ;; CHECK-NEXT:    (local.get $ref)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.get $A 2
  ;; CHECK-NEXT:    (local.get $ref)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.get $A 3
  ;; CHECK-NEXT:    (local.get $ref)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $A (param $x i32)
    (local $ref (ref null $A))
    (if
      (local.get $x)
      (local.set $ref
        (struct.new $A
          (i32.const 10) ;; Here the first two and last two are equivalent.
          (i32.const 10)
          (i32.const 20)
          (i32.const 20)
        )
      )
      (local.set $ref
        (struct.new $A
          (i32.const 10)
          (i32.const 20) ;; Here the middle two are equivalent. No overlap in
          (i32.const 20) ;; equivalences, so nothing is optimized below.
          (i32.const 30)
        )
      )
    )
    (drop
      (struct.get $A 0
        (local.get $ref)
      )
    )
    (drop
      (struct.get $A 1
        (local.get $ref)
      )
    )
    (drop
      (struct.get $A 2
        (local.get $ref)
      )
    )
    (drop
      (struct.get $A 3
        (local.get $ref)
      )
    )
  )
)

;; Four fields, now with optimizability.
(module
  ;; CHECK:      (type $A (struct (field i32) (field i32) (field i32) (field i32)))
  (type $A (struct (field i32) (field i32) (field i32) (field i32)))

  ;; CHECK:      (func $A (type $i32_=>_none) (param $x i32)
  ;; CHECK-NEXT:  (local $ref (ref null $A))
  ;; CHECK-NEXT:  (if
  ;; CHECK-NEXT:   (local.get $x)
  ;; CHECK-NEXT:   (local.set $ref
  ;; CHECK-NEXT:    (struct.new $A
  ;; CHECK-NEXT:     (i32.const 10)
  ;; CHECK-NEXT:     (i32.const 10)
  ;; CHECK-NEXT:     (i32.const 20)
  ;; CHECK-NEXT:     (i32.const 20)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:   (local.set $ref
  ;; CHECK-NEXT:    (struct.new $A
  ;; CHECK-NEXT:     (i32.const 10)
  ;; CHECK-NEXT:     (i32.const 20)
  ;; CHECK-NEXT:     (i32.const 20)
  ;; CHECK-NEXT:     (i32.const 20)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.get $A 0
  ;; CHECK-NEXT:    (local.get $ref)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.get $A 1
  ;; CHECK-NEXT:    (local.get $ref)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.get $A 2
  ;; CHECK-NEXT:    (local.get $ref)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.get $A 2
  ;; CHECK-NEXT:    (local.get $ref)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $A (param $x i32)
    (local $ref (ref null $A))
    (if
      (local.get $x)
      (local.set $ref
        (struct.new $A
          (i32.const 10)
          (i32.const 10)
          (i32.const 20)
          (i32.const 20)
        )
      )
      (local.set $ref
        (struct.new $A
          (i32.const 10)
          (i32.const 20) ;; Now the last three are equivalent. Combining with
          (i32.const 20) ;; the previous new, the last two remain equivalent.
          (i32.const 20)
        )
      )
    )
    (drop
      (struct.get $A 0
        (local.get $ref)
      )
    )
    (drop
      (struct.get $A 1
        (local.get $ref)
      )
    )
    (drop
      (struct.get $A 2
        (local.get $ref)
      )
    )
    (drop
      (struct.get $A 3
        (local.get $ref)
      )
    )
  )
)

;; Four fields, two pairs of whom are equivalent.
(module
  ;; CHECK:      (type $A (struct (field i32) (field i32) (field i32) (field i32)))
  (type $A (struct (field i32) (field i32) (field i32) (field i32)))

  ;; CHECK:      (func $A (type $none_=>_none)
  ;; CHECK-NEXT:  (local $ref (ref null $A))
  ;; CHECK-NEXT:  (local.set $ref
  ;; CHECK-NEXT:   (struct.new $A
  ;; CHECK-NEXT:    (i32.const 10)
  ;; CHECK-NEXT:    (i32.const 10)
  ;; CHECK-NEXT:    (i32.const 20)
  ;; CHECK-NEXT:    (i32.const 20)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.get $A 0
  ;; CHECK-NEXT:    (local.get $ref)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.get $A 0
  ;; CHECK-NEXT:    (local.get $ref)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.get $A 2
  ;; CHECK-NEXT:    (local.get $ref)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.get $A 2
  ;; CHECK-NEXT:    (local.get $ref)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $A
    (local $ref (ref null $A))
    (local.set $ref
      (struct.new $A
        (i32.const 10) ;; The first two and last two are equivalent, so we have
        (i32.const 10) ;; multiple optimization opportunities in a single type.
        (i32.const 20)
        (i32.const 20)
      )
    )
    (drop
      (struct.get $A 0
        (local.get $ref)
      )
    )
    (drop
      (struct.get $A 1
        (local.get $ref)
      )
    )
    (drop
      (struct.get $A 2
        (local.get $ref)
      )
    )
    (drop
      (struct.get $A 3
        (local.get $ref)
      )
    )
  )
)

;; Four fields, three of whom are equivalent.
(module
  ;; CHECK:      (type $A (struct (field i32) (field i32) (field i32) (field i32)))
  (type $A (struct (field i32) (field i32) (field i32) (field i32)))

  ;; CHECK:      (func $A (type $none_=>_none)
  ;; CHECK-NEXT:  (local $ref (ref null $A))
  ;; CHECK-NEXT:  (local.set $ref
  ;; CHECK-NEXT:   (struct.new $A
  ;; CHECK-NEXT:    (i32.const 10)
  ;; CHECK-NEXT:    (i32.const 10)
  ;; CHECK-NEXT:    (i32.const 20)
  ;; CHECK-NEXT:    (i32.const 10)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.get $A 0
  ;; CHECK-NEXT:    (local.get $ref)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.get $A 0
  ;; CHECK-NEXT:    (local.get $ref)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.get $A 2
  ;; CHECK-NEXT:    (local.get $ref)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.get $A 0
  ;; CHECK-NEXT:    (local.get $ref)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $A
    (local $ref (ref null $A))
    (local.set $ref
      (struct.new $A
        (i32.const 10)
        (i32.const 10)
        (i32.const 20)
        (i32.const 10) ;; The last one is equivalent to the first two.
      )
    )
    (drop
      (struct.get $A 0
        (local.get $ref)
      )
    )
    (drop
      (struct.get $A 1
        (local.get $ref)
      )
    )
    (drop
      (struct.get $A 2
        (local.get $ref)
      )
    )
    (drop
      (struct.get $A 3
        (local.get $ref)
      )
    )
  )
)

;; Mutable fields are not optimizable.
(module
  ;; CHECK:      (type $A (struct (field i32) (field (mut i32))))
  (type $A (struct (field i32) (field (mut i32)))) ;; One field is mutable.

  ;; CHECK:      (func $A (type $none_=>_none)
  ;; CHECK-NEXT:  (local $ref (ref null $A))
  ;; CHECK-NEXT:  (local.set $ref
  ;; CHECK-NEXT:   (struct.new $A
  ;; CHECK-NEXT:    (i32.const 10)
  ;; CHECK-NEXT:    (i32.const 10)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.get $A 0
  ;; CHECK-NEXT:    (local.get $ref)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.get $A 1
  ;; CHECK-NEXT:    (local.get $ref)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $A
    (local $ref (ref null $A))
    (local.set $ref
      (struct.new $A
        (i32.const 10)
        (i32.const 10)
      )
    )
    (drop
      (struct.get $A 0
        (local.get $ref)
      )
    )
    (drop
      (struct.get $A 1
        (local.get $ref)
      )
    )
  )
)

;; Non-constant fields: globals and unknowns.
(module
  ;; CHECK:      (type $A (struct (field i32) (field i32) (field i32) (field i32) (field i32) (field i32)))
  (type $A (struct (field i32) (field i32) (field i32) (field i32) (field i32) (field i32)))

  ;; CHECK:      (global $g10 i32 (i32.const 10))
  (global $g10 i32 (i32.const 10))

  ;; CHECK:      (global $g10-mut (mut i32) (i32.const 10))
  (global $g10-mut (mut i32) (i32.const 10))

  ;; CHECK:      (func $A (type $i32_=>_none) (param $x i32)
  ;; CHECK-NEXT:  (local $ref (ref null $A))
  ;; CHECK-NEXT:  (local.set $ref
  ;; CHECK-NEXT:   (struct.new $A
  ;; CHECK-NEXT:    (global.get $g10)
  ;; CHECK-NEXT:    (global.get $g10)
  ;; CHECK-NEXT:    (global.get $g10-mut)
  ;; CHECK-NEXT:    (global.get $g10-mut)
  ;; CHECK-NEXT:    (local.get $x)
  ;; CHECK-NEXT:    (local.get $x)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.get $A 0
  ;; CHECK-NEXT:    (local.get $ref)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.get $A 0
  ;; CHECK-NEXT:    (local.get $ref)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.get $A 2
  ;; CHECK-NEXT:    (local.get $ref)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.get $A 3
  ;; CHECK-NEXT:    (local.get $ref)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.get $A 4
  ;; CHECK-NEXT:    (local.get $ref)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.get $A 5
  ;; CHECK-NEXT:    (local.get $ref)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $A (param $x i32)
    (local $ref (ref null $A))
    (local.set $ref
      (struct.new $A
        ;; Immutable globals - these are equivalent.
        (global.get $g10)
        (global.get $g10)
        ;; Mutable globals, so we cannot optimize.
        (global.get $g10-mut)
        (global.get $g10-mut)
        ;; Completely unknown values.
        (local.get $x)
        (local.get $x)
      )
    )
    (drop
      (struct.get $A 0
        (local.get $ref)
      )
    )
    (drop
      (struct.get $A 1
        (local.get $ref)
      )
    )
    (drop
      (struct.get $A 2
        (local.get $ref)
      )
    )
    (drop
      (struct.get $A 3
        (local.get $ref)
      )
    )
    (drop
      (struct.get $A 4
        (local.get $ref)
      )
    )
    (drop
      (struct.get $A 5
        (local.get $ref)
      )
    )
  )
)

;; Subtyping. Here both types have the same equivalent fields, so we can
;; optimize them all to read field index #0.
(module
  ;; CHECK:      (type $A (struct (field i32) (field i32)))
  (type $A (struct_subtype (field i32) (field i32) data))
  ;; CHECK:      (type $B (struct_subtype (field i32) (field i32) $A))
  (type $B (struct_subtype (field i32) (field i32) $A))

  ;; CHECK:      (func $A (type $none_=>_none)
  ;; CHECK-NEXT:  (local $A (ref null $A))
  ;; CHECK-NEXT:  (local.set $A
  ;; CHECK-NEXT:   (struct.new $A
  ;; CHECK-NEXT:    (i32.const 10)
  ;; CHECK-NEXT:    (i32.const 10)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.get $A 0
  ;; CHECK-NEXT:    (local.get $A)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.get $A 0
  ;; CHECK-NEXT:    (local.get $A)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $A
    (local $A (ref null $A))
    (local.set $A
      (struct.new $A
        (i32.const 10)
        (i32.const 10)
      )
    )
    (drop
      (struct.get $A 0
        (local.get $A)
      )
    )
    (drop
      (struct.get $A 1
        (local.get $A)
      )
    )
  )

  ;; CHECK:      (func $B (type $none_=>_none)
  ;; CHECK-NEXT:  (local $B (ref null $B))
  ;; CHECK-NEXT:  (local.set $B
  ;; CHECK-NEXT:   (struct.new $B
  ;; CHECK-NEXT:    (i32.const 20)
  ;; CHECK-NEXT:    (i32.const 20)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.get $B 0
  ;; CHECK-NEXT:    (local.get $B)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.get $B 0
  ;; CHECK-NEXT:    (local.get $B)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $B
    (local $B (ref null $B))
    (local.set $B
      (struct.new $B
        (i32.const 20)
        (i32.const 20)
      )
    )
    (drop
      (struct.get $B 0
        (local.get $B)
      )
    )
    (drop
      (struct.get $B 1
        (local.get $B)
      )
    )
  )
)

;; Subtyping, but now the parent's fields are not equivalent, preventing
;; optimization there. But we can still optimize the child.
(module
  ;; CHECK:      (type $A (struct (field i32) (field i32)))
  (type $A (struct_subtype (field i32) (field i32) data))
  ;; CHECK:      (type $B (struct_subtype (field i32) (field i32) $A))
  (type $B (struct_subtype (field i32) (field i32) $A))

  ;; CHECK:      (func $A (type $none_=>_none)
  ;; CHECK-NEXT:  (local $A (ref null $A))
  ;; CHECK-NEXT:  (local.set $A
  ;; CHECK-NEXT:   (struct.new $A
  ;; CHECK-NEXT:    (i32.const 10)
  ;; CHECK-NEXT:    (i32.const 11)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.get $A 0
  ;; CHECK-NEXT:    (local.get $A)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.get $A 1
  ;; CHECK-NEXT:    (local.get $A)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $A
    (local $A (ref null $A))
    (local.set $A
      (struct.new $A
        (i32.const 10)
        (i32.const 11) ;; This changed.
      )
    )
    (drop
      (struct.get $A 0
        (local.get $A)
      )
    )
    (drop
      (struct.get $A 1
        (local.get $A)
      )
    )
  )

  ;; CHECK:      (func $B (type $none_=>_none)
  ;; CHECK-NEXT:  (local $B (ref null $B))
  ;; CHECK-NEXT:  (local.set $B
  ;; CHECK-NEXT:   (struct.new $B
  ;; CHECK-NEXT:    (i32.const 20)
  ;; CHECK-NEXT:    (i32.const 20)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.get $B 0
  ;; CHECK-NEXT:    (local.get $B)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.get $B 0
  ;; CHECK-NEXT:    (local.get $B)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $B
    (local $B (ref null $B))
    (local.set $B
      (struct.new $B
        (i32.const 20)
        (i32.const 20)
      )
    )
    (drop
      (struct.get $B 0
        (local.get $B)
      )
    )
    (drop
      (struct.get $B 1
        (local.get $B)
      )
    )
  )
)

;; Subtyping, but now the child's fields are not equivalent, preventing
;; optimization in both the parent and the child.
(module
  ;; CHECK:      (type $A (struct (field i32) (field i32)))
  (type $A (struct_subtype (field i32) (field i32) data))
  ;; CHECK:      (type $B (struct_subtype (field i32) (field i32) $A))
  (type $B (struct_subtype (field i32) (field i32) $A))

  ;; CHECK:      (func $A (type $none_=>_none)
  ;; CHECK-NEXT:  (local $A (ref null $A))
  ;; CHECK-NEXT:  (local.set $A
  ;; CHECK-NEXT:   (struct.new $A
  ;; CHECK-NEXT:    (i32.const 10)
  ;; CHECK-NEXT:    (i32.const 10)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.get $A 0
  ;; CHECK-NEXT:    (local.get $A)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.get $A 1
  ;; CHECK-NEXT:    (local.get $A)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $A
    (local $A (ref null $A))
    (local.set $A
      (struct.new $A
        (i32.const 10)
        (i32.const 10)
      )
    )
    (drop
      (struct.get $A 0
        (local.get $A)
      )
    )
    (drop
      (struct.get $A 1
        (local.get $A)
      )
    )
  )

  ;; CHECK:      (func $B (type $none_=>_none)
  ;; CHECK-NEXT:  (local $B (ref null $B))
  ;; CHECK-NEXT:  (local.set $B
  ;; CHECK-NEXT:   (struct.new $B
  ;; CHECK-NEXT:    (i32.const 20)
  ;; CHECK-NEXT:    (i32.const 22)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.get $B 0
  ;; CHECK-NEXT:    (local.get $B)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.get $B 1
  ;; CHECK-NEXT:    (local.get $B)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $B
    (local $B (ref null $B))
    (local.set $B
      (struct.new $B
        (i32.const 20)
        (i32.const 22) ;; This changed.
      )
    )
    (drop
      (struct.get $B 0
        (local.get $B)
      )
    )
    (drop
      (struct.get $B 1
        (local.get $B)
      )
    )
  )
)

;; Realistic vtable scenario. This is something no other optimization can handle
;; as we cannot simply infer the called function here - we can only infer
;; equivalence using this pass, and switch the get to the lower index.
;;
;; This also tests function references being optimized.
(module
  ;; CHECK:      (type $vtable (struct (field $op1 funcref) (field $op2 funcref)))
  (type $vtable (struct (field $op1 funcref) (field $op2 funcref)))

  ;; CHECK:      (type $A (struct (field $vtable (ref $vtable))))
  (type $A (struct_subtype (field $vtable (ref $vtable)) data))
  ;; CHECK:      (type $B (struct_subtype (field $vtable (ref $vtable)) $A))
  (type $B (struct_subtype (field $vtable (ref $vtable)) $A))

  ;; CHECK:      (global $vtable-A (ref $vtable) (struct.new $vtable
  ;; CHECK-NEXT:  (ref.func $func-a)
  ;; CHECK-NEXT:  (ref.func $func-a)
  ;; CHECK-NEXT: ))
  (global $vtable-A (ref $vtable) (struct.new $vtable
    (ref.func $func-a)
    (ref.func $func-a)
  ))

  ;; CHECK:      (global $vtable-B (ref $vtable) (struct.new $vtable
  ;; CHECK-NEXT:  (ref.func $func-b)
  ;; CHECK-NEXT:  (ref.func $func-b)
  ;; CHECK-NEXT: ))
  (global $vtable-B (ref $vtable) (struct.new $vtable
    (ref.func $func-b)
    (ref.func $func-b)
  ))

  ;; CHECK:      (func $func-a (type $none_=>_i32) (result i32)
  ;; CHECK-NEXT:  (i32.const 10)
  ;; CHECK-NEXT: )
  (func $func-a (result i32)
    (i32.const 10)
  )

  ;; CHECK:      (func $func-b (type $none_=>_i32) (result i32)
  ;; CHECK-NEXT:  (i32.const 10)
  ;; CHECK-NEXT: )
  (func $func-b (result i32)
    (i32.const 10)
  )

  ;; CHECK:      (func $A (type $i32_=>_none) (param $x i32)
  ;; CHECK-NEXT:  (local $ref (ref null $A))
  ;; CHECK-NEXT:  (if
  ;; CHECK-NEXT:   (local.get $x)
  ;; CHECK-NEXT:   (local.set $ref
  ;; CHECK-NEXT:    (struct.new $A
  ;; CHECK-NEXT:     (global.get $vtable-A)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:   (local.set $ref
  ;; CHECK-NEXT:    (struct.new $B
  ;; CHECK-NEXT:     (global.get $vtable-B)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.get $vtable $op1
  ;; CHECK-NEXT:    (struct.get $A $vtable
  ;; CHECK-NEXT:     (local.get $ref)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.get $vtable $op1
  ;; CHECK-NEXT:    (struct.get $A $vtable
  ;; CHECK-NEXT:     (local.get $ref)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $A (param $x i32)
    (local $ref (ref null $A))
    (if
      (local.get $x)
      (local.set $ref
        (struct.new $A
          (global.get $vtable-A)
        )
      )
      (local.set $ref
        (struct.new $B
          (global.get $vtable-B)
        )
      )
    )
    (drop
      (struct.get $vtable $op1
        (struct.get $A $vtable
          (local.get $ref)
        )
      )
    )
    (drop
      (struct.get $vtable $op2 ;; This can be switched to op2.
        (struct.get $A $vtable
          (local.get $ref)
        )
      )
    )
  )
)

;; TODO nesting in both struct.new operands and globalas with structnews
