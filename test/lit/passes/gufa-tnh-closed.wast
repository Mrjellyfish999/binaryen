;; NOTE: Assertions have been generated by update_lit_checks.py --all-items and should not be edited.
;; RUN: foreach %s %t wasm-opt -all --gufa -tnh --closed-world -S -o - | filecheck %s

;; A CallRef with no non-trapping targets must be unreachable if traps never
;; happen, in a closed world, which is what this file tests.
(module
  (rec
    ;; CHECK:      (rec
    ;; CHECK-NEXT:  (type $A (func))
    (type $A (func))
    ;; CHECK:       (type $B (func))
    (type $B (func))
  )

  ;; CHECK:      (type $funcref_=>_none (func (param funcref)))

  ;; CHECK:      (export "out" (func $caller))

  ;; CHECK:      (func $impossible (type $A)
  ;; CHECK-NEXT:  (unreachable)
  ;; CHECK-NEXT: )
  (func $impossible (type $A)
    ;; This cannot be called if traps never happen.
    (unreachable)
  )

  ;; CHECK:      (func $irrelevant (type $B)
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (i32.const 20)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $irrelevant (type $B)
    ;; This has a similar but different type, so it is irrelevant to this
    ;; optimization.
    (drop
      (i32.const 20)
    )
  )

  ;; CHECK:      (func $caller (type $funcref_=>_none) (param $x funcref)
  ;; CHECK-NEXT:  (block ;; (replaces something unreachable we can't emit)
  ;; CHECK-NEXT:   (drop
  ;; CHECK-NEXT:    (unreachable)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:   (unreachable)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $caller (export "out") (param $x funcref)
    ;; This call must trap: the only function of the right type will trap.
    (call_ref $A
      (ref.cast $A
        (local.get $x)
      )
    )
  )
)

;; As above, but now there are no functions of type $A at all.
(module
  (rec
    ;; CHECK:      (type $funcref_=>_none (func (param funcref)))

    ;; CHECK:      (rec
    ;; CHECK-NEXT:  (type $A (func))
    (type $A (func))
    ;; CHECK:       (type $B (func))
    (type $B (func))
  )

  ;; CHECK:      (export "out" (func $caller))

  ;; CHECK:      (func $irrelevant (type $B)
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (i32.const 20)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $irrelevant (type $B)
    ;; This has a similar but different type, so it is irrelevant to this
    ;; optimization.
    (drop
      (i32.const 20)
    )
  )

  ;; CHECK:      (func $caller (type $funcref_=>_none) (param $x funcref)
  ;; CHECK-NEXT:  (block ;; (replaces something unreachable we can't emit)
  ;; CHECK-NEXT:   (drop
  ;; CHECK-NEXT:    (unreachable)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:   (unreachable)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $caller (export "out") (param $x funcref)
    ;; No function exists of type $A, so this will trap.
    (call_ref $A
      (ref.cast $A
        (local.get $x)
      )
    )
  )
)

;; As above, but now there is a function that can be called.
(module
  (rec
    ;; CHECK:      (rec
    ;; CHECK-NEXT:  (type $A (func))
    (type $A (func))
    ;; CHECK:       (type $B (func))
    (type $B (func))
  )

  ;; CHECK:      (type $funcref_=>_none (func (param funcref)))

  ;; CHECK:      (elem declare func $possible)

  ;; CHECK:      (export "out" (func $caller))

  ;; CHECK:      (func $possible (type $A)
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (i32.const 10)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $possible (type $A)
    (drop
      (i32.const 10)
    )
  )

  ;; CHECK:      (func $caller (type $funcref_=>_none) (param $x funcref)
  ;; CHECK-NEXT:  (call_ref $A
  ;; CHECK-NEXT:   (ref.func $possible)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $caller (export "out") (param $x funcref)
    ;; This must call $possible.
    (call_ref $A
      (ref.cast $A
        (local.get $x)
      )
    )
  )
)

;; TODO: one target has a param that will trap
