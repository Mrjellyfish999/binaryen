;; NOTE: Assertions have been generated by update_lit_checks.py --all-items and should not be edited.
;; RUN: foreach %s %t wasm-opt -all --gufa -tnh --closed-world -S -o - | filecheck %s

;; A CallRef with no non-trapping targets must be unreachable if traps never
;; happen, in a closed world, which is what this file tests.
(module
  (rec
    ;; CHECK:      (rec
    ;; CHECK-NEXT:  (type $A (func))
    (type $A (func))
    ;; CHECK:       (type $B (func))
    (type $B (func))
  )

  ;; CHECK:      (type $funcref_=>_none (func (param funcref)))

  ;; CHECK:      (export "out" (func $caller))

  ;; CHECK:      (func $impossible (type $A)
  ;; CHECK-NEXT:  (unreachable)
  ;; CHECK-NEXT: )
  (func $impossible (type $A)
    ;; This cannot be called if traps never happen.
    (unreachable)
  )

  ;; CHECK:      (func $irrelevant (type $B)
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (i32.const 20)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $irrelevant (type $B)
    ;; This has a similar but different type, so it is irrelevant to this
    ;; optimization.
    (drop
      (i32.const 20)
    )
  )

  ;; CHECK:      (func $caller (type $funcref_=>_none) (param $x funcref)
  ;; CHECK-NEXT:  (block ;; (replaces something unreachable we can't emit)
  ;; CHECK-NEXT:   (drop
  ;; CHECK-NEXT:    (unreachable)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:   (unreachable)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $caller (export "out") (param $x funcref)
    ;; This call must trap: the only function of the right type will trap.
    (call_ref $A
      (ref.cast $A
        (local.get $x)
      )
    )
  )
)

;; As above, but now there are no functions of type $A at all.
(module
  (rec
    ;; CHECK:      (type $funcref_=>_none (func (param funcref)))

    ;; CHECK:      (rec
    ;; CHECK-NEXT:  (type $A (func))
    (type $A (func))
    ;; CHECK:       (type $B (func))
    (type $B (func))
  )

  ;; CHECK:      (export "out" (func $caller))

  ;; CHECK:      (func $irrelevant (type $B)
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (i32.const 20)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $irrelevant (type $B)
    ;; This has a similar but different type, so it is irrelevant to this
    ;; optimization.
    (drop
      (i32.const 20)
    )
  )

  ;; CHECK:      (func $caller (type $funcref_=>_none) (param $x funcref)
  ;; CHECK-NEXT:  (block ;; (replaces something unreachable we can't emit)
  ;; CHECK-NEXT:   (drop
  ;; CHECK-NEXT:    (unreachable)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:   (unreachable)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $caller (export "out") (param $x funcref)
    ;; No function exists of type $A, so this will trap.
    (call_ref $A
      (ref.cast $A
        (local.get $x)
      )
    )
  )
)

;; As above, but now there is a function that can be called.
(module
  ;; CHECK:      (type $A (func))
  (type $A (func))

  ;; CHECK:      (type $funcref_=>_none (func (param funcref)))

  ;; CHECK:      (elem declare func $possible)

  ;; CHECK:      (export "out" (func $caller))

  ;; CHECK:      (func $possible (type $A)
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (i32.const 10)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $possible (type $A)
    (drop
      (i32.const 10)
    )
  )

  ;; CHECK:      (func $caller (type $funcref_=>_none) (param $x funcref)
  ;; CHECK-NEXT:  (call_ref $A
  ;; CHECK-NEXT:   (ref.func $possible)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $caller (export "out") (param $x funcref)
    ;; This must call $possible.
    (call_ref $A
      (ref.cast $A
        (local.get $x)
      )
    )
  )
)

;; As above, with another function of that type that traps.
(module
  ;; CHECK:      (type $A (func))
  (type $A (func))

  ;; CHECK:      (type $funcref_=>_none (func (param funcref)))

  ;; CHECK:      (elem declare func $possible)

  ;; CHECK:      (export "out" (func $caller))

  ;; CHECK:      (func $possible (type $A)
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (i32.const 10)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $possible (type $A)
    (drop
      (i32.const 10)
    )
  )

  ;; CHECK:      (func $impossible (type $A)
  ;; CHECK-NEXT:  (unreachable)
  ;; CHECK-NEXT: )
  (func $impossible (type $A)
    (unreachable)
  )

  ;; CHECK:      (func $caller (type $funcref_=>_none) (param $x funcref)
  ;; CHECK-NEXT:  (call_ref $A
  ;; CHECK-NEXT:   (ref.func $possible)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $caller (export "out") (param $x funcref)
    ;; This must call $possible, as the trapping function won't be called.
    (call_ref $A
      (ref.cast $A
        (local.get $x)
      )
    )
  )
)

;; As above, but now we have two possible functions. We cannot optimize here.
(module
  ;; CHECK:      (type $A (func))
  (type $A (func))

  ;; CHECK:      (type $funcref_=>_none (func (param funcref)))

  ;; CHECK:      (export "out" (func $caller))

  ;; CHECK:      (func $possible (type $A)
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (i32.const 10)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $possible (type $A)
    (drop
      (i32.const 10)
    )
  )

  ;; CHECK:      (func $possible-2 (type $A)
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (i32.const 20)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $possible-2 (type $A)
    (drop
      (i32.const 20)
    )
  )

  ;; CHECK:      (func $caller (type $funcref_=>_none) (param $x funcref)
  ;; CHECK-NEXT:  (call_ref $A
  ;; CHECK-NEXT:   (ref.cast $A
  ;; CHECK-NEXT:    (local.get $x)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $caller (export "out") (param $x funcref)
    (call_ref $A
      (ref.cast $A
        (local.get $x)
      )
    )
  )
)

;; As above, but now the second possible function is of a subtype. We still
;; cannot optimize a call to the parent, but we can for the child.
(module
  ;; CHECK:      (type $A (func))
  (type $A (func))

  ;; CHECK:      (type $B (sub $A (func)))
  (type $B (sub $A (func)))

  ;; CHECK:      (type $funcref_=>_none (func (param funcref)))

  ;; CHECK:      (elem declare func $possible-2)

  ;; CHECK:      (export "out" (func $caller))

  ;; CHECK:      (func $possible (type $A)
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (i32.const 10)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $possible (type $A)
    (drop
      (i32.const 10)
    )
  )

  ;; CHECK:      (func $possible-2 (type $B)
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (i32.const 20)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $possible-2 (type $B)
    (drop
      (i32.const 20)
    )
  )

  ;; CHECK:      (func $caller (type $funcref_=>_none) (param $x funcref)
  ;; CHECK-NEXT:  (call_ref $A
  ;; CHECK-NEXT:   (ref.cast $A
  ;; CHECK-NEXT:    (local.get $x)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (call_ref $B
  ;; CHECK-NEXT:   (ref.func $possible-2)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $caller (export "out") (param $x funcref)
    ;; A has one function, but it has a subtype with another, so we cannot
    ;; optimize
    (call_ref $A
      (ref.cast $A
        (local.get $x)
      )
    )
    ;; The second call can be optimized, as B has just one function.
    (call_ref $B
      (ref.cast $B
        (local.get $x)
      )
    )
  )
)

;; Two possible functions, but one has a parameter that will trap.
(module

  (rec
    ;; CHECK:      (rec
    ;; CHECK-NEXT:  (type $X (struct ))
    (type $X (struct))

    ;; CHECK:       (type $Y1 (sub $X (struct )))
    (type $Y1 (sub $X (struct)))

    ;; CHECK:       (type $Y2 (sub $X (struct )))
    (type $Y2 (sub $X (struct)))

    ;; CHECK:       (type $A (func (param anyref)))
    (type $A (func (param anyref)))
  )

  ;; CHECK:      (type $funcref_funcref_funcref_structref_structref_structref_=>_none (func (param funcref funcref funcref structref structref structref)))

  ;; CHECK:      (elem declare func $possible-Y1 $possible-Y2)

  ;; CHECK:      (export "out" (func $caller))

  ;; CHECK:      (func $possible-Y1 (type $A) (param $ref anyref)
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (unreachable) YIKES
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $possible-Y1 (type $A) (param $ref anyref)
    (drop
      (ref.cast $Y1
        (local.get $ref)
      )
    )
  )

  ;; CHECK:      (func $possible-Y2 (type $A) (param $ref anyref)
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (unreachable) YIKES
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $possible-Y2 (type $A) (param $ref anyref)
    (drop
      (ref.cast $Y2
        (local.get $ref)
      )
    )
  )

  ;; CHECK:      (func $caller (type $funcref_funcref_funcref_structref_structref_structref_=>_none) (param $func1 funcref) (param $func2 funcref) (param $func3 funcref) (param $ref1 structref) (param $ref2 structref) (param $ref3 structref)
  ;; CHECK-NEXT:  (call_ref $A
  ;; CHECK-NEXT:   (ref.cast $Y1
  ;; CHECK-NEXT:    (local.get $ref1)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:   (ref.func $possible-Y1)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (call_ref $A
  ;; CHECK-NEXT:   (ref.cast $Y2
  ;; CHECK-NEXT:    (local.get $ref2)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:   (ref.func $possible-Y2)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (block ;; (replaces something unreachable we can't emit)
  ;; CHECK-NEXT:   (drop
  ;; CHECK-NEXT:    (local.get $ref3)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:   (drop
  ;; CHECK-NEXT:    (unreachable) YIKES
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:   (unreachable) YIKES
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $caller (export "out")
    (param $func1 funcref)
    (param $func2 funcref)
    (param $func3 funcref)
    (param $ref1 structref)
    (param $ref2 structref)
    (param $ref3 structref)

    ;; This would trap if we called the function that casts to Y2, so we must be
    ;; calling possible-Y1.
    (call_ref $A
      (ref.cast $Y1
        (local.get $ref1)
      )
      (ref.cast $A
        (local.get $func1)
      )
    )
    ;; Inverse of the above: we must call possible-Y2.
    (call_ref $A
      (ref.cast $Y2
        (local.get $ref2)
      )
      (ref.cast $A
        (local.get $func2)
      )
    )
    ;; This can call either one, and cannot be optimized.
    (call_ref $A
      (local.get $ref3)
      (ref.cast $A
        (local.get $func3)
      )
    )
  )
)
