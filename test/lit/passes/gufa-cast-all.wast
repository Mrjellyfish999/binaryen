;; NOTE: Assertions have been generated by update_lit_checks.py --all-items and should not be edited.

;; RUN: foreach %s %t wasm-opt -all --gufa --optimize-level=2 -S -o - | filecheck %s --check-prefix=OPT_2
;; RUN: foreach %s %t wasm-opt -all --gufa --optimize-level=3 -S -o - | filecheck %s --check-prefix=OPT_3

;; Compare the behavior at optimization level 2 and 3. At 3 we will add all the
;; casts we possibly can infer.

(module
  ;; OPT_2:      (type $none_=>_none (func))

  ;; OPT_2:      (type $A (struct ))
  ;; OPT_3:      (type $none_=>_none (func))

  ;; OPT_3:      (type $A (struct ))
  (type $A (struct))

  ;; OPT_2:      (type $B (sub $A (struct )))
  ;; OPT_3:      (type $B (sub $A (struct )))
  (type $B (sub $A (struct)))

  ;; OPT_2:      (export "export1" (func $ref))

  ;; OPT_2:      (export "export2" (func $int))

  ;; OPT_2:      (export "export3" (func $unreachable))

  ;; OPT_2:      (func $ref (type $none_=>_none)
  ;; OPT_2-NEXT:  (local $a (ref $A))
  ;; OPT_2-NEXT:  (local.set $a
  ;; OPT_2-NEXT:   (struct.new_default $B)
  ;; OPT_2-NEXT:  )
  ;; OPT_2-NEXT:  (drop
  ;; OPT_2-NEXT:   (ref.cast $B
  ;; OPT_2-NEXT:    (local.get $a)
  ;; OPT_2-NEXT:   )
  ;; OPT_2-NEXT:  )
  ;; OPT_2-NEXT: )
  ;; OPT_3:      (export "export1" (func $ref))

  ;; OPT_3:      (export "export2" (func $int))

  ;; OPT_3:      (export "export3" (func $unreachable))

  ;; OPT_3:      (func $ref (type $none_=>_none)
  ;; OPT_3-NEXT:  (local $a (ref $A))
  ;; OPT_3-NEXT:  (local.set $a
  ;; OPT_3-NEXT:   (struct.new_default $B)
  ;; OPT_3-NEXT:  )
  ;; OPT_3-NEXT:  (drop
  ;; OPT_3-NEXT:   (ref.cast $B
  ;; OPT_3-NEXT:    (local.get $a)
  ;; OPT_3-NEXT:   )
  ;; OPT_3-NEXT:  )
  ;; OPT_3-NEXT: )
  (func $ref (export "export1")
    (local $a (ref $A))
    (local.set $a
      (struct.new $B)
    )
    (drop
      ;; We can infer that this contains B, and add a cast to that type, when
      ;; the optimization level is 3.
      (local.get $a)
    )
  )

  ;; OPT_2:      (func $int (type $none_=>_none)
  ;; OPT_2-NEXT:  (local $a i32)
  ;; OPT_2-NEXT:  (local.set $a
  ;; OPT_2-NEXT:   (i32.const 1)
  ;; OPT_2-NEXT:  )
  ;; OPT_2-NEXT:  (drop
  ;; OPT_2-NEXT:   (i32.const 1)
  ;; OPT_2-NEXT:  )
  ;; OPT_2-NEXT: )
  ;; OPT_3:      (func $int (type $none_=>_none)
  ;; OPT_3-NEXT:  (local $a i32)
  ;; OPT_3-NEXT:  (local.set $a
  ;; OPT_3-NEXT:   (i32.const 1)
  ;; OPT_3-NEXT:  )
  ;; OPT_3-NEXT:  (drop
  ;; OPT_3-NEXT:   (i32.const 1)
  ;; OPT_3-NEXT:  )
  ;; OPT_3-NEXT: )
  (func $int (export "export2")
    (local $a i32)
    (local.set $a
      (i32.const 1)
    )
    (drop
      ;; We can infer that this contains 1, but there is nothing to do regarding
      ;; the type, which is not a reference.
      (local.get $a)
    )
  )

  ;; OPT_2:      (func $unreachable (type $none_=>_none)
  ;; OPT_2-NEXT:  (local $a (ref $A))
  ;; OPT_2-NEXT:  (local.tee $a
  ;; OPT_2-NEXT:   (unreachable)
  ;; OPT_2-NEXT:  )
  ;; OPT_2-NEXT:  (drop
  ;; OPT_2-NEXT:   (unreachable)
  ;; OPT_2-NEXT:  )
  ;; OPT_2-NEXT: )
  ;; OPT_3:      (func $unreachable (type $none_=>_none)
  ;; OPT_3-NEXT:  (local $a (ref $A))
  ;; OPT_3-NEXT:  (local.tee $a
  ;; OPT_3-NEXT:   (unreachable)
  ;; OPT_3-NEXT:  )
  ;; OPT_3-NEXT:  (drop
  ;; OPT_3-NEXT:   (unreachable)
  ;; OPT_3-NEXT:  )
  ;; OPT_3-NEXT: )
  (func $unreachable (export "export3")
    (local $a (ref $A))
    (local.set $a
      (unreachable)
    )
    (drop
      ;; We can infer that the type here is unreachable, but there is nothing
      ;; special to do for that in optimize level 3 vs 2 - we emit an
      ;; unreachable either way.
      (local.get $a)
    )
  )
)
